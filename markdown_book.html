<h3 id="indepedent-completed-but-tried-at-5-times">indepedent completed, but tried at 5 times</h3>
<ul>
<li>Point questions tip: original pointer -&gt; null</li>
</ul>
<h3 id="before-hunting">Before hunting:</h3>
<ul>
<li>required constant space complexity how the pointer move is a key</li>
</ul>
<h3 id="solution">Solution</h3>
<ul>
<li>Non recursive</li>
<li>Space O(1), Time: O(n)</li>
</ul>
<h3 id="solution---0">Solution - 0</h3>
<ul>
<li>Recursive Solution</li>
<li>Space O(1), Time: O(n) (ignore recursive stack space)</li>
</ul>
<h1 id="question-is-easy-multiple-recursive-methods">Question is easy, multiple recursive methods:</h1>
<h4 id="solution-1">Solution</h4>
<ul>
<li>pass totalsum, pathsum and return totalsum – paramters are not perfect</li>
</ul>
<h4 id="solution---0-1">Solution - 0</h4>
<ul>
<li>apply totalsum as global variable – which is not recommand</li>
</ul>
<h4 id="solution---1">Solution - 1</h4>
<ul>
<li>from others’ submition, which is bereif and easy</li>
</ul>
<p>This is the solution i am able to write it done.But take many errors in the process:</p>
<ol type="1">
<li>negative number bit operation:</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">int</span> n =  <span class="dv">-1</span>;</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">n &gt;&gt; i <span class="co">//(i in [1,31]) all return -1</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">//so should use:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">n / <span class="dv">2</span> to move right</a></code></pre></div>
<ol start="2" type="1">
<li>need seperated flag to check the number is negative?</li>
<li><div class="line-block">and &amp; bit operations:</div>
There is summary: https://docs.google.com/document/d/1AOOJXhyQ72ghnNkpUdQNL0HdZZfgLDh42m3HjKtSU_k/edit</li>
</ol>
<p>bit operation:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">int</span> i = <span class="dv">-1</span>;</a></code></pre></div>
<h3 id="图的复制">图的复制</h3>
<p>复杂度一般是O(V + E) 需要用Map来维护original和new的node之间对应关系 此题不算图的复制，而是ListNode的复制，加一个random的复制，可以做到O(n)</p>
<h3 id="donot-understand-the-meaning-of-the-question">Donot understand the meaning of the question</h3>
<p>until get the artical : * https://leetcode.com/problems/binary-tree-upside-down/discuss/49406/Java-recursive-(O(logn)-space)-and-iterative-solutions-(O(1)-space)-with-explanation-and-figure</p>
<p>###conditional substring of string question looks need sliding window to solve</p>
<p>HashMap, array could be as window</p>
<p>for this issue, array should get best performance</p>
<h3 id="question-is-easy-but-trade-off-need-to-clarify-before-shutting.">Question is easy, but trade off need to clarify before shutting.</h3>
<p>for this question: only one operation in <code>add</code> and <code>find</code> could be O(1), another should be O(n) or O(n ^ 2)</p>
<h3 id="bstiterator-basic">BSTIterator basic</h3>
<ul>
<li>this is the method i think only method for this question. actually not</li>
</ul>
<h3 id="bstiterator---0">BSTIterator - 0</h3>
<ul>
<li>make a inorder traverse at first</li>
</ul>
<h3 id="straforward-solution">Straforward solution:</h3>
<ul>
<li>Solution - 0 using a set/map to keep mid result. if the result comes out again, return false. Otherwise, keep going, until result == 1 or it was found happen before.</li>
</ul>
<p>But Space complexity is O(n)</p>
<ul>
<li>Solution - 1 There is anther solution only cost O(1) space. the idea is similar to fast/slow point solution for determining whether cycle existed in graph.</li>
</ul>
<p>got an error: incomparable types: char and <null> , when execute:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">char</span> c = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(c == <span class="kw">null</span>);</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">// the wrong code:</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">} <span class="kw">else</span> <span class="kw">if</span> (map.<span class="fu">get</span>(cs) == ct &amp;&amp; opmap.<span class="fu">get</span>(ct) == cs) {</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">//the right one:</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">} <span class="kw">else</span> <span class="kw">if</span> (<span class="kw">new</span> <span class="bu">Character</span>(ct).<span class="fu">equals</span>(map.<span class="fu">get</span>(cs)) &amp;&amp; <span class="kw">new</span> <span class="bu">Character</span>(cs).<span class="fu">equals</span>(opmap.<span class="fu">get</span>(ct))) {</a></code></pre></div>
<h3 id="solution---1-1">Solution - 1</h3>
<p>int[] is better than HashMap in this question</p>
<h1 id="solution-basic">Solution basic</h1>
<ul>
<li>tc : O(logn) + O(2 * log(n - 1)) + …. O( 2^log(n - 1) * 1 )</li>
</ul>
<h1 id="solution-0">Solution – 0</h1>
<ul>
<li>tc : looks like O(logn ^ 2)</li>
</ul>
<h1 id="solution-test">Solution –test</h1>
<p>confused the following code :</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" data-line-number="1">            <span class="kw">if</span> (node.<span class="fu">val</span> != <span class="dv">-100</span>) {</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">                node.<span class="fu">val</span> = <span class="dv">-100</span>;</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">              <span class="kw">...  </span></a></code></pre></div>
<p>which will effect the performance a lot, not sure the reason</p>
<h1 id="time-complexity">Time complexity</h1>
<p>Looks like O(log(n) ^ 2) – height solution</p>
<p>O(n) – bfs solution</p>
<h2 id="solution-basic-1">Solution – basic</h2>
<ul>
<li>Optimaze:</li>
</ul>
<ol type="1">
<li>if size of list === k, it can stop</li>
<li>applied a number instead of list (Solution - 0)</li>
</ol>
<h1 id="solution---basic">Solution - basic</h1>
<ul>
<li>Time Limit Exceed</li>
</ul>
<h1 id="solution---0-2">Solution - 0</h1>
<ul>
<li>Passed: Time Complexity: O(n) – get path may access all nodes</li>
</ul>
<h1 id="solution---1-2">Solution - 1</h1>
<ul>
<li><p>Amazing solution</p></li>
<li><p>proof by contradiction</p></li>
</ul>
<h1 id="solution---basic-1">Solution - basic</h1>
<ul>
<li>inorder to get values as a list firstly, then binary search to find the value first</li>
<li>Time complexity: O(n) + O(logn)</li>
<li><p>Space complexity: O(n)</p></li>
<li><p>Summary: unnecessary complicated</p></li>
</ul>
<h1 id="solution---0-3">Solution - 0</h1>
<ul>
<li><p>recursively range filter the closest value: need to maintain the current largest value, smallest value.</p></li>
<li>Time : avg: O(h), worest: O(n), best: O(1)</li>
<li>Space : avg: O(h), worest: O(n), best: O(1) – recursive call space</li>
<li><p>Summary: meanwhile maintain closest large, closest small value is not the best solution</p></li>
</ul>
<h1 id="solution---1-2-1">Solution - 1 &amp; 2</h1>
<ul>
<li>came from others’: idea is same, recursive &amp; loop</li>
<li><p>the idea is like binary search, each time we know the current node &gt; or &lt; the target, if &gt;, the possible result must be itself or left subtree.</p></li>
<li><p>Time/Space is the same to the previous</p></li>
</ul>
<h3 id="solution-2">Solution :</h3>
<ul>
<li><p>binary search – works</p></li>
<li><p>TC : O(n) + O(nlogn) + O(lgn) total: O(nlogn)</p></li>
</ul>
<p>###Solution - 1</p>
<ul>
<li>Map</li>
<li>O(n)</li>
<li>accumlate add in Map</li>
</ul>
<h3 id="solution-3">Solution</h3>
<ul>
<li>the solution is ok. but found a interesting solution, please see below:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">class</span> Solution {</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">getHint</span>(<span class="bu">String</span> secret, <span class="bu">String</span> guess) {</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">int</span> bulls = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        <span class="dt">int</span> cows = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">        <span class="dt">int</span>[] c = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">        <span class="dt">char</span>[] cs = secret.<span class="fu">toCharArray</span>();</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">        <span class="dt">char</span>[] cg = guess.<span class="fu">toCharArray</span>();</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; cs.<span class="fu">length</span>; i++) {</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">            <span class="dt">int</span> s = cs[i]-<span class="ch">&#39;0&#39;</span>;</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">            <span class="dt">int</span> g = cg[i]-<span class="ch">&#39;0&#39;</span>;</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">            <span class="kw">if</span>(s==g) {</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">                bulls++;</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">            } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">                <span class="kw">if</span> (c[s]++&lt;<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">                    cows++;</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">                }</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">                <span class="kw">if</span> (c[g]--&gt;<span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">                    cows++;</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">                }</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">            }</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">        }</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">        <span class="kw">return</span> bulls + <span class="st">&quot;A&quot;</span> + cows + <span class="st">&quot;B&quot;</span>;</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">}</a></code></pre></div>
<h3 id="matrix-multiply-rules">matrix multiply rules:</h3>
<ul>
<li>https://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%9://zh.wikihow.com/%E8%AE%A1%E7%AE%97%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95 计算规则是，第一个矩阵第一行的每个数字（2和1），各自乘以第二个矩阵第一列对应位置的数字（1和1），然后将乘积相加（ 2 x 1 + 1 x 1），得到结果矩阵左上角的那个值3。</li>
</ul>
<p>Map ### Solution * solved it but small issues a few times</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" data-line-number="1"></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">//wrong:</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">max = <span class="bu">Math</span>.<span class="fu">max</span>(max, i - map.<span class="fu">get</span>(sum - k) + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">//correct:</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">max = <span class="bu">Math</span>.<span class="fu">max</span>(max, i - map.<span class="fu">get</span>(sum - k));</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">// in this question, the begin index should be excluded</span></a></code></pre></div>
<h3 id="solution-4">Solution</h3>
<ul>
<li>PriorityQueue, time complexsity: O(n) + O(klogk)</li>
</ul>
<h3 id="solution---1-3">Solution - 1</h3>
<ul>
<li>Bucket sort</li>
</ul>
<ol type="1">
<li>time complexity: O(n) + O(n)</li>
</ol>
<h3 id="solution---2">Solution - 2</h3>
<ul>
<li>TreeMap</li>
</ul>
<ol type="1">
<li>time complexity: O(n + klogk)</li>
</ol>
<h1 id="hash-table-using-question">Hash table using question</h1>
<h3 id="follow-up-1.-for-real-twitter-lots-of-users-lots-of-tweets-how-to-solve">follow up: 1. for real twitter: lots of users, lots of tweets, how to solve</h3>
<h3 id="solution-5">Solution</h3>
<ul>
<li><p>PriorityQueue usage: for each followees’ recent 10 tweets need to go into PriorityQueue. which is more than it should be</p></li>
<li>PriorityQueue: is mininum heap</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="bu">PriorityQueue</span> pr = <span class="kw">new</span> <span class="bu">PriorityQueue</span>();</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">//the mininum element always can be poll first;</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">pr.<span class="fu">poll</span>() <span class="co">//return the mininum element</span></a></code></pre></div>
<h3 id="question-is-easy-but-its-a-good-question-to-follow-up">question is easy, but it’s a good question to follow up</h3>
<ol type="1">
<li><p>if message is a object or with structure md5 as a key may be ok</p></li>
<li><p>lots of request with different key more than one process to handle different key or distrubited map: and inside, to prevent exception, the map need to lock to access</p></li>
<li><p>long time passed, the capcity of map? need a queue to store last successful keys if each time to check, need to check the timestamp of last key in the queue, if it is exceed 10s. delete the key and the value in map</p></li>
</ol>
<h1 id="note">Note</h1>
<ul>
<li>Tree traversal from bottom to top</li>
</ul>
<h5 id="wrong-code">Wrong code:</h5>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" data-line-number="1">    <span class="kw">if</span> (map.<span class="fu">containsKey</span>(startc)) {</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        <span class="kw">if</span> (wmap.<span class="fu">get</span>(startc) == map.<span class="fu">get</span>(startc)) count--;</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">        wmap.<span class="fu">put</span>(startc, wmap.<span class="fu">getOrDefault</span>(startc, <span class="dv">0</span>) - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    }</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">SHOULD BE <span class="kw">if</span> (wmap.<span class="fu">get</span>(startc) &lt;= map.<span class="fu">get</span>(startc)) count--;</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">Both  == and &lt; the count in template , count-- </a></code></pre></div>
<h3 id="for-solution---0">for solution - 0</h3>
<ul>
<li>java collection.addall time complexity: didn’t find out precise answer: general speaking, for arraylist.addAll, it should do following operations:</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" data-line-number="1">  <span class="co">//1. resize the target array</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="co">//2. copy all elements in 2nd array to target array</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="co">// second step should cost O(O)</span></a></code></pre></div>
<p>** but for linkedlist.addAll(linkedlist), it should only take O(1) time complexity ** Actually arraylist.addAll(arraylist) got better performance.</p>
<h3 id="solution---1-4">solution - 1</h3>
<p>standard solution for dfs</p>
<h3 id="solution---2-1">solution - 2</h3>
<p>personal bfs solution with visited HashSet to check it is traversed or not</p>
<h3 id="solution---3">solution - 3</h3>
<p>standard bfs solution only with Stack</p>
<h2 id="analysis">Analysis</h2>
<ul>
<li>dp question</li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb10-1" data-line-number="1">dp[<span class="dv">0</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">dp[<span class="dv">1</span>] = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">dp[<span class="dv">2</span>] = dp[<span class="dv">0</span>] * dp[<span class="dv">2</span> - <span class="dv">1</span>] + dp[<span class="dv">1</span>] * dp[<span class="dv">0</span>] <span class="co">// dp[2] = 2;</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">dp[<span class="dv">3</span>] = dp[<span class="dv">0</span>] * dp[<span class="dv">3</span> - <span class="dv">1</span>] + dp[<span class="dv">1</span>] * dp[<span class="dv">3</span> - <span class="dv">2</span>] + dp[<span class="dv">2</span>] * dp[<span class="dv">3</span> - <span class="dv">2</span> - <span class="dv">1</span>]<span class="co">// dp[3] = 2 + 1 + 2 = 5;</span></a></code></pre></div>
<h1 id="lt-2018">lt-2018</h1>
<h3 id="char-int">char &lt;===&gt; int</h3>
<p>char to int char increase assign int to char</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="dt">char</span> a = <span class="ch">&#39;h&#39;</span>;</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(a + <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="co">//105</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>((<span class="dt">char</span>)( a + <span class="dv">1</span> ));</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="co">//i</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="dt">char</span> s = <span class="dv">100</span>;</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s);</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="co">//d</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="dt">char</span> x = <span class="ch">&#39;a&#39;</span>;</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="dt">int</span>[] arr = <span class="kw">new</span> <span class="dt">int</span>[<span class="dv">256</span>];</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">arr[x] =<span class="dv">121</span>;</a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="co">//Correct</span></a></code></pre></div>
<h3 id="int-integer-under-array-and-arraylist">int, Integer under array and ArrayList</h3>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">// in java8 stream is better to convert</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dt">int</span>[] intarray = <span class="kw">new</span> <span class="dt">int</span>[]{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">6</span>};</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">// to Integer[]</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="bu">Integer</span>[] arr = <span class="kw">new</span> <span class="bu">Integer</span>[intarray.<span class="fu">length</span>];</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span> ; i &lt; intarray.<span class="fu">length</span>; i++) {</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    arr[i] = <span class="bu">Integer</span>.<span class="fu">valueOf</span>(intarray[i]);</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">}</a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co">//to List&lt;Integer&gt;</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co">//ERROR :</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">list = <span class="bu">Arrays</span>.<span class="fu">asList</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>);</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="co">//CORRECT:</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="kw">for</span> (<span class="dt">int</span> i: intarray) {</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    list.<span class="fu">add</span>(i);</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">}</a></code></pre></div>
<h3 id="char-character">char &amp; Character</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="dt">char</span> s = <span class="dv">100</span>;</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;equals: &quot;</span> + (<span class="kw">new</span> <span class="bu">Character</span>(<span class="ch">&#39;d&#39;</span>)).<span class="fu">equals</span>(s)); </a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">// true</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;==: &quot;</span> + (<span class="kw">new</span> <span class="bu">Character</span>(<span class="ch">&#39;d&#39;</span>) == s));</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co">// true</span></a></code></pre></div>
<h3 id="collections">Collections</h3>
<ul>
<li>reverse list</li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="bu">Collections</span>.<span class="fu">reverse</span>(list);</a></code></pre></div>
<ul>
<li>define a List array</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt;[] listarr = <span class="kw">new</span> <span class="bu">List</span>[<span class="dv">10</span>];</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">//The following is wrong:</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt;[] listarr = <span class="kw">new</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt;[<span class="dv">10</span>];</a></code></pre></div>
<ul>
<li>sublist</li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="bu">Arrays</span>.<span class="fu">asList</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>);</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">list.<span class="fu">subList</span>(<span class="dv">0</span>, <span class="dv">3</span>); <span class="co">//fromIndex, toIndex </span></a></code></pre></div>
<h3 id="maptreemap">Map/TreeMap</h3>
<ul>
<li>TreeMap – get last</li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="bu">TreeMap</span>&lt;<span class="bu">Integer</span>, <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt;&gt; tmap = <span class="kw">new</span> <span class="bu">TreeMap</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="bu">Map</span>.<span class="fu">Entry</span>&lt;<span class="bu">Integer</span>, <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt;&gt; entry = tmap.<span class="fu">pollLastEntry</span>();</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = entry.<span class="fu">getValue</span>();</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th>Collections</th>
<th style="text-align: center;">Get</th>
<th style="text-align: right;">ContainsKey</th>
<th style="text-align: right;">Next</th>
<th style="text-align: right;">Data Structure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>HashMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(h / n)</td>
<td style="text-align: right;">Hash Table</td>
</tr>
<tr class="even">
<td>LinkedHashMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">Hash Table + Linked List</td>
</tr>
<tr class="odd">
<td>TreeMap</td>
<td style="text-align: center;">O(log n)</td>
<td style="text-align: right;">O(log n)</td>
<td style="text-align: right;">O(log n)</td>
<td style="text-align: right;">Red-black tree</td>
</tr>
<tr class="even">
<td>ConcurrentHashMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(h / n)</td>
<td style="text-align: right;">Hash Tables</td>
</tr>
<tr class="odd">
<td>ConcurrentSkipListMap</td>
<td style="text-align: center;">O(log n)</td>
<td style="text-align: right;">O(log n)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">Skip List</td>
</tr>
<tr class="even">
<td>IdentityHashMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(h / n)</td>
<td style="text-align: right;">Array</td>
</tr>
<tr class="odd">
<td>WeakHashMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(h / n)</td>
<td style="text-align: right;">Hash Table</td>
</tr>
<tr class="even">
<td>EnumMap</td>
<td style="text-align: center;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">O(1)</td>
<td style="text-align: right;">Array</td>
</tr>
</tbody>
</table>
<h3 id="int-long">int &lt;===&gt; long</h3>
<ul>
<li>int to long, auto convert</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="dt">int</span> a = <span class="dv">34</span>;</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="dt">void</span> <span class="fu">test</span>(<span class="dt">long</span> param) {</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(param);</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="fu">test</span>(a);</a></code></pre></div>
<h3 id="char-space">char space</h3>
<ul>
<li><p>An ASCII character in 8-bit ASCII encoding is 8 bits (1 byte), though it can fit in 7 bits.</p></li>
<li><p>An ISO-8895-1 character in ISO-8859-1 encoding is 8 bits (1 byte).</p></li>
<li><p>A Unicode character in UTF-8 encoding is between 8 bits (1 byte) and 32 bits (4 bytes).</p></li>
<li><p>A Unicode character in UTF-16 encoding is between 16 (2 bytes) and 32 bits (4 bytes), though most of the common characters take 16 bits. This is the encoding used by Windows internally.</p></li>
<li><p>A Unicode character in UTF-32 encoding is always 32 bits (4 bytes).</p></li>
<li><p>An ASCII character in UTF-8 is 8 bits (1 byte), and in UTF-16 - 16 bits.</p></li>
<li><p>The additional (non-ASCII) characters in ISO-8895-1 (0xA0-0xFF) would take 16 bits in UTF-8 and UTF-16.</p></li>
</ul>
<h3 id="integer-space">integer space</h3>
<ul>
<li>ref: https://stackoverflow.com/questions/29251563/use-of-wrapper-class-increases-size-of-object</li>
</ul>
<pre><code>The instances of these classes will typically be the same size. On most JVMs, it uses 32-bit references so your wrapper with two 32-bit values (int or references) will be the same, about 24 bytes in total on a 64-bit JVM.

In a 64-bit JVM, the default header size is 12 bytes, the references will be 32-bit with Compressed Oops, and an 8 byte alignment will be a total size of 24 bytes.

Header - 12 bytes with 64-bit class references
int or ref - 4 bytes
int or ref - 4 bytes
align to multiple of 8 - +4 bytes
==========
Total - 24 bytes
If the references are 64-bit (e.g. &gt; 64 GB heaps) it will use 8 bytes per reference and the total size will be 32 bytes. However, if the alignment is 16 as well (for heaps between 32 - 64 GB) then the pair of int wrapper will also be 32 bytes.

If you are concerned about total space consumed, and the Integer is not cached i.e. is a new Integer, the total space can be a further 16 bytes per Integer. If the Integer is cached, it doesn&#39;t use any more space.</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>27d8c00d0af7a870b9cf64df6002c7aba10da4ed</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>granularity <a href="https://translate.google.com/#en/zh-CN/granularity">粒度</a> atomic <a href="https://translate.google.com/#en/zh-CN/atomic">原子</a> sparse matrices <a href="https://translate.google.com/#en/zh-CN/sparse">link</a> primitive <a href="https://translate.google.com/#en/zh-CN/primitive">link</a> exponent <a href="https://translate.google.com/#en/zh-CN/exponent">link</a> proof by contradiction – 反证法</p>
<h1 id="notice">notice:</h1>
<ol type="1">
<li>total, map, start these 3 vars need to maintain together in 1.1 in side of 1st loop:</li>
</ol>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb20-1" data-line-number="1">            <span class="bu">Map</span>&lt;<span class="bu">String</span>, <span class="bu">Integer</span>&gt; map = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;(template);</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">            total = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">            <span class="dt">int</span> j = i, start = i;</a></code></pre></div>
<p>1.2 current substring is not dictionary</p>
<pre><code>                    map = new HashMap(template);
                    j += wlen;
                    start = j;
                    total = 0;</code></pre>
<p>1.3 current substring is in dict but too more, window map keep going</p>
<pre><code>                while (map.get(sb) &lt;= 0) {
                    String begin = s.substring(start, start + wlen);
                    //   System.out.println(begin + &quot;, &quot; +map.get(begin) + &quot;, &quot; + start + &quot;, &quot; + map + &quot;, sb=&quot; + sb);
                    map.put(begin, map.get(begin) + 1);
                    start += wlen;
                    total--;
                }</code></pre>
<p>1.4 total === words.length : when find out a result, the window need to keep sliding forward</p>
<pre><code>                    String begin = s.substring(start, start + wlen);
                    map.put(begin, map.get(begin) + 1);
                    start += wlen;
                    total--;
</code></pre>
<ol start="2" type="1">
<li><p>to prevent duplicated traverse: 2.1 outer loop while (i &lt; wlen) 2.2 inner loop while (j &lt;= s.length() - wlen) // note =</p></li>
<li>silding window template: from https://leetcode.com/problems/minimum-window-substring/discuss/26808/here-is-a-10-line-template-that-can-solve-most-substring-problems</li>
</ol>
<pre><code>// input: string s or  string[] words
int[] map = new int[128]; 
// or Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();

int len = s.length() 
// or int len = words.length;

int counter = 0;
int start = 0, end = 0;
for() { /* initialize the hash map here */ }
while (end &lt; len) {
}

</code></pre>
<pre><code>int findSubstring(string s){
        vector&lt;int&gt; map(128,0);
        int counter; // check whether the substring is valid
        int begin=0, end=0; //two pointers, one point to tail and one  head
        int d; //the length of substring

        for() { /* initialize the hash map here */ }

        while(end&lt;s.size()){

            if(map[s[end++]]-- ?){  /* modify counter here */ }

            while(/* counter condition */){ 
                 
                 /* update d here if finding minimum*/

                //increase begin to make it invalid/valid again
                
                if(map[s[begin++]]++ ?){ /*modify counter here*/ }
            }  

            /* update d here if finding maximum*/
        }
        return d;
  }</code></pre>
<h3 id="bst-binary-search-tree">BST: binary search tree:</h3>
<h3 id="traverse">Traverse</h3>
<ul>
<li>Queue for BFS and so on ** 101.symmetric-tree.java Solution1 applied reverse order level travse</li>
</ul>
<h3 id="inorder-preorderpostorder">inorder/ preorder/postorder</h3>
<ul>
<li>pre order iteratively</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">preorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="kw">if</span>(root == <span class="kw">null</span>) <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="bu">Stack</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">Stack</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    stack.<span class="fu">push</span>(root);</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    <span class="kw">while</span>(!stack.<span class="fu">empty</span>()){</a>
<a class="sourceLine" id="cb26-7" data-line-number="7">        root = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">        list.<span class="fu">add</span>(root.<span class="fu">val</span>);</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">        <span class="kw">if</span>(root.<span class="fu">right</span> != <span class="kw">null</span>) stack.<span class="fu">push</span>(root.<span class="fu">right</span>);</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">        <span class="kw">if</span>(root.<span class="fu">left</span> != <span class="kw">null</span>) stack.<span class="fu">push</span>(root.<span class="fu">left</span>);</a>
<a class="sourceLine" id="cb26-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">    <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb26-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb26-14" data-line-number="14"><span class="co">//Another template</span></a>
<a class="sourceLine" id="cb26-15" data-line-number="15"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">preorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb26-16" data-line-number="16">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; result = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb26-17" data-line-number="17">    <span class="bu">Deque</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">ArrayDeque</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb26-18" data-line-number="18">    <span class="bu">TreeNode</span> p = root;</a>
<a class="sourceLine" id="cb26-19" data-line-number="19">    <span class="kw">while</span>(!stack.<span class="fu">isEmpty</span>() || p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb26-20" data-line-number="20">        <span class="kw">if</span>(p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb26-21" data-line-number="21">            stack.<span class="fu">push</span>(p);</a>
<a class="sourceLine" id="cb26-22" data-line-number="22">            result.<span class="fu">add</span>(p.<span class="fu">val</span>);  <span class="co">// Add before going to children</span></a>
<a class="sourceLine" id="cb26-23" data-line-number="23">            p = p.<span class="fu">left</span>;</a>
<a class="sourceLine" id="cb26-24" data-line-number="24">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb26-25" data-line-number="25">            <span class="bu">TreeNode</span> node = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb26-26" data-line-number="26">            p = node.<span class="fu">right</span>;   </a>
<a class="sourceLine" id="cb26-27" data-line-number="27">        }</a>
<a class="sourceLine" id="cb26-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb26-29" data-line-number="29">    <span class="kw">return</span> result;</a>
<a class="sourceLine" id="cb26-30" data-line-number="30">}</a></code></pre></div>
<ul>
<li>in order iteratively</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb27-1" data-line-number="1"></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="co">// standard template</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">inorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    <span class="kw">if</span> (root == <span class="kw">null</span>) <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    <span class="bu">Stack</span>&lt;<span class="bu">TreeNode</span>&gt; stk = <span class="kw">new</span> <span class="bu">Stack</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-7" data-line-number="7"></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    <span class="kw">while</span> (root != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">        stk.<span class="fu">push</span>(root);</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">        root = root.<span class="fu">left</span>;</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb27-12" data-line-number="12">    <span class="kw">while</span> (!stk.<span class="fu">isEmpty</span>()) {</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">        <span class="bu">TreeNode</span> node = stk.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb27-14" data-line-number="14">        list.<span class="fu">add</span>(node.<span class="fu">val</span>);</a>
<a class="sourceLine" id="cb27-15" data-line-number="15">        <span class="kw">if</span> (node.<span class="fu">right</span> != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">            <span class="bu">TreeNode</span> rl = node.<span class="fu">right</span>;</a>
<a class="sourceLine" id="cb27-17" data-line-number="17">            <span class="kw">while</span> (rl != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb27-18" data-line-number="18">                stk.<span class="fu">push</span>(rl);</a>
<a class="sourceLine" id="cb27-19" data-line-number="19">                rl = rl.<span class="fu">left</span>;</a>
<a class="sourceLine" id="cb27-20" data-line-number="20">            }</a>
<a class="sourceLine" id="cb27-21" data-line-number="21">        }</a>
<a class="sourceLine" id="cb27-22" data-line-number="22">    }</a>
<a class="sourceLine" id="cb27-23" data-line-number="23">    <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb27-24" data-line-number="24">}</a>
<a class="sourceLine" id="cb27-25" data-line-number="25"><span class="co">//Template - 1</span></a>
<a class="sourceLine" id="cb27-26" data-line-number="26"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">inorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb27-27" data-line-number="27">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-28" data-line-number="28">    <span class="kw">if</span>(root == <span class="kw">null</span>) <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb27-29" data-line-number="29">    <span class="bu">Stack</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">Stack</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-30" data-line-number="30">    <span class="kw">while</span>(root != <span class="kw">null</span> || !stack.<span class="fu">empty</span>()){</a>
<a class="sourceLine" id="cb27-31" data-line-number="31">        <span class="kw">while</span>(root != <span class="kw">null</span>){</a>
<a class="sourceLine" id="cb27-32" data-line-number="32">            stack.<span class="fu">push</span>(root);</a>
<a class="sourceLine" id="cb27-33" data-line-number="33">            root = root.<span class="fu">left</span>;</a>
<a class="sourceLine" id="cb27-34" data-line-number="34">        }</a>
<a class="sourceLine" id="cb27-35" data-line-number="35">        root = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb27-36" data-line-number="36">        list.<span class="fu">add</span>(root.<span class="fu">val</span>);</a>
<a class="sourceLine" id="cb27-37" data-line-number="37">        root = root.<span class="fu">right</span>;</a>
<a class="sourceLine" id="cb27-38" data-line-number="38">    }</a>
<a class="sourceLine" id="cb27-39" data-line-number="39">    <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb27-40" data-line-number="40">}</a>
<a class="sourceLine" id="cb27-41" data-line-number="41"><span class="co">// Another Template</span></a>
<a class="sourceLine" id="cb27-42" data-line-number="42"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">inorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb27-43" data-line-number="43">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; result = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-44" data-line-number="44">    <span class="bu">Deque</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">ArrayDeque</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb27-45" data-line-number="45">    <span class="bu">TreeNode</span> p = root;</a>
<a class="sourceLine" id="cb27-46" data-line-number="46">    <span class="kw">while</span>(!stack.<span class="fu">isEmpty</span>() || p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb27-47" data-line-number="47">        <span class="kw">if</span>(p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb27-48" data-line-number="48">            stack.<span class="fu">push</span>(p);</a>
<a class="sourceLine" id="cb27-49" data-line-number="49">            p = p.<span class="fu">left</span>;</a>
<a class="sourceLine" id="cb27-50" data-line-number="50">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb27-51" data-line-number="51">            <span class="bu">TreeNode</span> node = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb27-52" data-line-number="52">            result.<span class="fu">add</span>(node.<span class="fu">val</span>);  <span class="co">// Add after all left children</span></a>
<a class="sourceLine" id="cb27-53" data-line-number="53">            p = node.<span class="fu">right</span>;   </a>
<a class="sourceLine" id="cb27-54" data-line-number="54">        }</a>
<a class="sourceLine" id="cb27-55" data-line-number="55">    }</a>
<a class="sourceLine" id="cb27-56" data-line-number="56">    <span class="kw">return</span> result;</a>
<a class="sourceLine" id="cb27-57" data-line-number="57">}</a></code></pre></div>
<ul>
<li>post order iteratively</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">postorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; list = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    <span class="kw">if</span>(root == <span class="kw">null</span>) <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">    <span class="bu">Stack</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">Stack</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    stack.<span class="fu">push</span>(root);</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">    <span class="kw">while</span>(!stack.<span class="fu">empty</span>()){</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">        root = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">        list.<span class="fu">add</span>(<span class="dv">0</span>, root.<span class="fu">val</span>);</a>
<a class="sourceLine" id="cb28-9" data-line-number="9">        <span class="kw">if</span>(root.<span class="fu">left</span> != <span class="kw">null</span>) stack.<span class="fu">push</span>(root.<span class="fu">left</span>);</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">        <span class="kw">if</span>(root.<span class="fu">right</span> != <span class="kw">null</span>) stack.<span class="fu">push</span>(root.<span class="fu">right</span>);</a>
<a class="sourceLine" id="cb28-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">    <span class="kw">return</span> list;</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">}</a>
<a class="sourceLine" id="cb28-14" data-line-number="14"><span class="co">//Another template</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15"><span class="kw">public</span> <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; <span class="fu">postorderTraversal</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb28-16" data-line-number="16">    <span class="bu">LinkedList</span>&lt;<span class="bu">Integer</span>&gt; result = <span class="kw">new</span> <span class="bu">LinkedList</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    <span class="bu">Deque</span>&lt;<span class="bu">TreeNode</span>&gt; stack = <span class="kw">new</span> <span class="bu">ArrayDeque</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb28-18" data-line-number="18">    <span class="bu">TreeNode</span> p = root;</a>
<a class="sourceLine" id="cb28-19" data-line-number="19">    <span class="kw">while</span>(!stack.<span class="fu">isEmpty</span>() || p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb28-20" data-line-number="20">        <span class="kw">if</span>(p != <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb28-21" data-line-number="21">            stack.<span class="fu">push</span>(p);</a>
<a class="sourceLine" id="cb28-22" data-line-number="22">            result.<span class="fu">addFirst</span>(p.<span class="fu">val</span>);  <span class="co">// Reverse the process of preorder</span></a>
<a class="sourceLine" id="cb28-23" data-line-number="23">            p = p.<span class="fu">right</span>;             <span class="co">// Reverse the process of preorder</span></a>
<a class="sourceLine" id="cb28-24" data-line-number="24">        } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb28-25" data-line-number="25">            <span class="bu">TreeNode</span> node = stack.<span class="fu">pop</span>();</a>
<a class="sourceLine" id="cb28-26" data-line-number="26">            p = node.<span class="fu">left</span>;           <span class="co">// Reverse the process of preorder</span></a>
<a class="sourceLine" id="cb28-27" data-line-number="27">        }</a>
<a class="sourceLine" id="cb28-28" data-line-number="28">    }</a>
<a class="sourceLine" id="cb28-29" data-line-number="29">    <span class="kw">return</span> result;</a>
<a class="sourceLine" id="cb28-30" data-line-number="30">}</a></code></pre></div>
